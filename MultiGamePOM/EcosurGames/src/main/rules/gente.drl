/*
* Copyright (C) 2008 ECOSUR, Andrew Waterman and Max Pimm
* 
* Licensed under the Academic Free License v. 3.0. 
* http://www.opensource.org/licenses/afl-3.0.php
*/

package mx.ecosur.multigame.impl.pente;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import mx.ecosur.multigame.Color;
import mx.ecosur.multigame.GameState;
import mx.ecosur.multigame.MessageSender;

import mx.ecosur.multigame.ejb.entity.Cell;
import mx.ecosur.multigame.ejb.entity.GameGrid;
import mx.ecosur.multigame.ejb.entity.Move.*;
import mx.ecosur.multigame.ejb.entity.Game;
import mx.ecosur.multigame.ejb.entity.GamePlayer;

import mx.ecosur.multigame.impl.ejb.entity.pente.PenteGame;
import mx.ecosur.multigame.impl.ejb.entity.pente.PentePlayer;
import mx.ecosur.multigame.impl.ejb.entity.pente.PenteMove;

import mx.ecosur.multigame.impl.util.Direction;

#GENTE

#These rules have been seperated from the main Pente rule set for 
#use in the modified game of Pente, GENTE, invented by 
#Dr. Luis Garcia Barrios at ECOSUR, in San Cristobal de Las Casas,
#Chiapas, Mexico.


#Functions for the modified Game of PENTE, "GENTE"

/*
    Determines if the destination of the requested move
    is in the center of the grid.
*/
function boolean isCenter (PenteGame game, PenteMove move) {
    Dimension size = game.getSize();
    Cell destination = move.getDestination ();
    
    int centerWidth = (int) size.getWidth()/2;
    int centerHeight = (int) size.getHeight()/2;
    
    boolean ret = (destination.getRow () == centerHeight && 
        destination.getColumn() == centerWidth);
    if (!ret)
        move.setStatus (Status.INVALID);
    return ret;
}

/*
    Determines if the destination of the requested move is
    empty on the grid.
*/
function boolean isEmpty (GameGrid grid, PenteMove move) {
    Cell destination = move.getDestination();
    Cell current = grid.getLocation (destination);
    boolean ret = (current == null);
    if (!ret)
        move.setStatus (Status.INVALID);
    return ret;
}

function boolean isTria (PenteMove move) {
    return (move.getTrias().size() > 0);
}

function boolean isTessera (PenteMove move) {
    return (move.getTesseras().size() > 0);
}

function int scorePlayer (PenteMove move) {
    int ret = 0;
    PentePlayer player = (PentePlayer) move.getPlayer();
    if (player.getTrias().size() >= 2)
        ret = 10;
    else if (player.getTesseras().size() >= 3) 
        ret = 5;
    return ret;
}

/*
    Determines if the game has a winner.
*/
function boolean hasWinner (PenteGame game) {
    return (game.getWinners().size() > 0);
}

/*
    Gets the winner from a specified game.  For more complicated payoff
    schemas, this function should return a PriorityQueue of Players 
    based upon positions on the board.
*/
function Set getWinners (PenteGame game) {   
    PenteGame pente = (PenteGame) game;
    return pente.getWinners();
}

function GamePlayer incrementTurn (PenteMove move) {
    GamePlayer player = move.getPlayer();    
    player.setTurn(false);

    /* Find next player */
    List<GamePlayer> players = player.getGame().getPlayers();
    int playerNumber = players.indexOf(player);
    GamePlayer nextPlayer = null;
    if (playerNumber == players.size() - 1) {
        nextPlayer = players.get(0);
    } else {
        nextPlayer = players.get(playerNumber + 1);
    }
    
    nextPlayer.setTurn (true);
    return nextPlayer;
}

#Rules for the game of PENTE

#Sets the players in the game so that Black has the first turn
#Sets up the empty game grid and sets thate game into the PLAY state
rule "setup"
    agenda-group "initialize"
when
    game : PenteGame (state == GameState.BEGIN)
then
    List<GamePlayer> players = game.getPlayers();
    for (GamePlayer p : players) {
        if (p.getColor() == Color.YELLOW)
            p.setTurn(true);
        else
            p.setTurn(false);
    }
    GameGrid grid = new GameGrid ();
    modify (game) { setGrid (grid), setState (GameState.PLAY), setPlayers (players) } 
    MessageSender messageSender = new MessageSender();
    messageSender.sendPlayerChange(game);
    messageSender.sendStartGame(game);
end

#Yellow must move first, and that move can only be at the center of the board
rule "evaluate-first-move"
    agenda-group "verify"
when
    game  : PenteGame (state == GameState.PLAY, $grid : grid)
    move  : PenteMove (status == Status.UNVERIFIED, player.turn == true, player.color == Color.YELLOW)
    eval ($grid.getCells().isEmpty())
    eval (isCenter (game, move))    
then
    modify (move) { setStatus (Status.VERIFIED) }
end

#Subsequent moves must occur on a non-empty board, on empty locations
rule "evaluate-move"
    agenda-group "verify"
when
    game  : PenteGame (state == GameState.PLAY, $grid : grid)
    move  : PenteMove (status == Status.UNVERIFIED, player.turn == true)
    eval (!$grid.getCells().isEmpty())
    eval (isEmpty (game.getGrid(), move))   
then
    modify (move) { setStatus (Status.VERIFIED) }
end   

# Executes a simple move
rule "execute-move"
    agenda-group "move"
when 
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.VERIFIED)  
then 
    GameGrid modifiedGrid = game.getGrid();   
    modifiedGrid.updateCell (move.getDestination());
    #Calculate Trias and Tesseras before serialziing move over jms.
    move.getTrias();
    move.getTesseras();
    modify (move) { setStatus (Status.MOVED) }
    modify (game) { setGrid (modifiedGrid) }
    MessageSender messageSender = new MessageSender();
    messageSender.sendMoveComplete(move);
end
 
rule "find-the-trias"
    agenda-group "evaluate"
    no-loop true 
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.MOVED)
    eval (!isTessera (move))
    eval (isTria (move))
then
    PentePlayer player = (PentePlayer) move.getPlayer();
    Set <BeadString> trias = move.getTrias();
    for (BeadString  t : trias) {
        player.addTria(t);
    }
    modify (move) { setPlayer (player), setStatus (Status.EVALUATED) }
end

rule "find-the-tesseras"
    agenda-group "evaluate"
    no-loop true
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.MOVED)
    eval (isTessera (move))
    eval (!isTria (move))
then
    PentePlayer player = (PentePlayer) move.getPlayer();
    PentePlayer partner = (PentePlayer) player.getPartner();
    Set<BeadString> tesseras = move.getTesseras();
    for (BeadString  t : tesseras) {
        player.addTessera (t);
        partner.addTessera (t);
    }
    modify (move) { setPlayer (player), setStatus (Status.EVALUATED) }
end

rule "find-the-mixed"
    agenda-group "evaluate"
    no-loop true
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.MOVED)
    eval (isTria (move))
    eval (isTessera (move))
then
    PentePlayer player = (PentePlayer) move.getPlayer();
    PentePlayer partner = (PentePlayer) player.getPartner();
    Set<BeadString> tesseras = move.getTesseras();
    Set<BeadString> trias = move.getTrias();
    Set<BeadString> unadded = new HashSet<BeadString>();
    for (BeadString  tessera : tesseras) {
        for (BeadString tria: trias) {
                player.addTria(tria);
                player.addTessera (tessera); 
                partner.addTessera (tessera);
        }
    }
    modify (move) { setPlayer (player), setStatus (Status.EVALUATED) }
end

rule "evaluate-nonscoring-move"
    agenda-group "evaluate"
    no-loop true
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.MOVED)
    eval (!isTria (move)) and eval (!isTessera (move))
then
    modify (move) { setStatus (Status.EVALUATED) }
end 

rule "score"
    agenda-group "evaluate"
    no-loop true
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.EVALUATED)
then
    int score = scorePlayer (move);
    PentePlayer player = (PentePlayer) move.getPlayer ();
    if (score > 0) {
        Set<PentePlayer> winners = new HashSet<PentePlayer>();
        if (score == 5) {
            PentePlayer teammate = player.getPartner();
            teammate.setPoints (score);
            winners.add(teammate);
        }
        player.setPoints (score);
        winners.add(player);
        modify (move) { setPlayer (player) }
        modify (game) { setWinners (winners) }
    }
end

# Finds the winner 
rule "find-the-winner"
    agenda-group "evaluate"
    no-loop true
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.EVALUATED)
    eval (hasWinner(game))
then
    Set<PentePlayer> winners = getWinners (game);
    modify (game) { setState (GameState.END), setWinners (winners) }
    MessageSender messageSender = new MessageSender();
	messageSender.sendEndGame (game);
end

rule "increment-turn"
    agenda-group "evaluate"
    no-loop true
    salience -1
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Status.EVALUATED)
then
    GamePlayer player = incrementTurn (move);
    MessageSender messageSender = new MessageSender();
    messageSender.sendPlayerChange(player.getGame());
end