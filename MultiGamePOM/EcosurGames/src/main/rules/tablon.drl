package mx.ecosur.multigame.tablon;

/*
* Copyright (C) 2009 ECOSUR, Andrew Waterman
*
* Licensed under the Academic Free License v. 3.0.
* http://www.opensource.org/licenses/afl-3.0.php
*/

import java.util.Date;
import java.util.SortedSet;
import java.util.List;

import mx.ecosur.multigame.impl.Color;
import mx.ecosur.multigame.enums.GameState;
import mx.ecosur.multigame.enums.MoveStatus;

import mx.ecosur.multigame.MessageSender;

import mx.ecosur.multigame.impl.model.*;
import mx.ecosur.multigame.impl.entity.tablon.*;
import mx.ecosur.multigame.impl.enums.tablon.TokenType;

import mx.ecosur.multigame.impl.util.tablon.MutationEvent;
import mx.ecosur.multigame.impl.util.tablon.MutationEvent.MutationType;

import function mx.ecosur.multigame.impl.util.tablon.RuleFunctions.*;

/**
    Tablon is a meta-game built with the purpose of players adding in their own rules to control
    resource usage.  The game has a set of environmental constraints, which, under the right
    circumstances will create a catastrophic failure.

    Game design:  Luis Garc’a Barrios
    Game implementation:  Andrew Glenn Waterman
*/

global MessageSender messageSender;

dialect "java"

rule "setup"
    ruleflow-group "initialize"
    no-loop true
when
    $game : TablonGame (state == GameState.BEGIN);
then
    $game.setCreated(new Date());
    $game.setColumns(25);
    $game.setRows(25);   
    List<GridPlayer> players = $game.getPlayers();
    for (GridPlayer p : players) {
        if (p.getColor() == Color.YELLOW)
            p.setTurn(true);
        else
            p.setTurn(false);
    }
    TablonGrid grid = new TablonGrid ();
    /* Populate the grid */
    for (int col = 1; col < 26; col++) {
        for (int row = 1; row < 26; row++) {
            if ( (col == 13 && row == 1) || (col == 1 && row == 13) || (col == 13 && row == 25) || (col == 25 && row == 13))
                continue;
            else if ( (col + row) % 2 != 0)
                continue;

            if ( row % 2 == 1 || col % 2 == 1) {
                /* soil or water */
                if ( (col > 11 && col < 15) || (row > 11 && row < 15)) {
                    TablonFicha waterParticle = new TablonFicha (col, row, Color.UNKNOWN, TokenType.WATER_PARTICLE);
                    grid.updateCell (waterParticle);

                } else {
                    TablonFicha soilParticle = new TablonFicha (col, row, Color.UNKNOWN, TokenType.SOIL_PARTICLE);
                    grid.updateCell (soilParticle);
                }

            } else {
                TablonFicha forest = new TablonFicha (col, row, Color.UNKNOWN, TokenType.FOREST);
                grid.updateCell (forest);
            }
        }
    }
    
    modify ($game) { setGrid (grid), setState (GameState.PLAY), setPlayers (players)}
    messageSender.sendPlayerChange($game);
    messageSender.sendStartGame($game);
end


rule "verify-move"
    ruleflow-group "verify"
when
    $game  : TablonGame (state == GameState.PLAY, $grid : grid)
    $move  : TablonMove (badYear == false, status == MoveStatus.UNVERIFIED, player.turn == true)
    eval ( ((TablonFicha) $grid.getLocation ($move.getDestinationCell())).getType ().equals (TokenType.FOREST))
then
    modify ($move) { setStatus (MoveStatus.VERIFIED) }
end


rule "verify-update-move"
    ruleflow-group "verify"
when
    $game  : TablonGame (state == GameState.PLAY, $grid : grid)
    $move  : TablonMove (badYear == false, status == MoveStatus.UNVERIFIED, player.turn == true)
    eval ( ( (TablonFicha) $move.getDestinationCell() ).getType().equals (TokenType.SILVOPASTORAL) )
    eval ( ( (TablonFicha) $grid.getLocation ($move.getDestinationCell()) ).getType().equals (TokenType.POTRERO))
then
    modify ($move) { setStatus (MoveStatus.VERIFIED) }
end

rule "do-move"
   ruleflow-group "move"
when
    $game  : TablonGame  (state == GameState.PLAY, $grid : grid)
    $move  : TablonMove  (badYear == false, status == MoveStatus.VERIFIED, player.turn == true)
then
    TablonFicha ficha = (TablonFicha) $move.getDestinationCell();
    GridCell cell =$grid.getLocation(ficha);
    $grid.updateCell (ficha);        
    TablonGrid tgrid = (TablonGrid) $grid;
    MutationEvent mutation = new MutationEvent (ficha);
    mutation.setSquare (tgrid.getSquare(ficha));
    mutation.setOctogon (tgrid.getOctogon(ficha));
    incrementTurn ($game, $move);
    modify ($move) { setStatus (MoveStatus.MOVED) }
    insert (tgrid);
    insert (mutation);
    for (TablonFicha particle : mutation.getSquare()) {
        if (particle.getRow() == 1 || particle.getColumn() == 1 || particle.getRow () == 25 || particle.getColumn() == 25)
            continue;
        MutationEvent event = new MutationEvent (particle, MutationType.NOTIFY);
        event.setSquare(tgrid.getSquare(particle));
        insert (event);
    }
    for (TablonFicha forest : mutation.getOctogon()) {
        if (forest == null)
            continue;
        if (forest.getRow() == 2 || forest.getColumn() == 2 || forest.getRow() == 24 || forest.getColumn() == 24)
            continue;
        MutationEvent event = new MutationEvent (forest, MutationType.NOTIFY);
        event.setSquare(tgrid.getSquare(forest));
        event.setOctogon(tgrid.getOctogon(forest));
        insert (event);
    }
end

# Environmental constraints

rule "A single Potrero token cannot be supported by only one soil token"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.POTRERO, $square : square)
    eval (isUnary ($ficha, $square, TokenType.SOIL_PARTICLE))
    $grid : TablonGrid ()    
then
    modify ($grid) { removeCell($ficha) }
    retract ($event);
    for (Object obj : $square) {
        TablonFicha ficha = (TablonFicha) obj;
        #Borders are ignored
        if (ficha.getRow () == 1 || ficha.getColumn() == 1)
            continue;
        MutationEvent MutationEvent = new MutationEvent (ficha, MutationType.RETRACT);
        MutationEvent.setSquare ($grid.getSquare(ficha));
        MutationEvent.setOctogon ($grid.getOctogon(ficha));
        insert (MutationEvent);
    }
end

rule "A single soil token cannot be supported by only one forest token"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.SOIL_PARTICLE, $square : square)
    eval (isUnary ($ficha, $square, TokenType.FOREST))
    $grid : TablonGrid ()
then
    modify ($grid) { removeCell($ficha) }
    retract ($event);
    for (Object obj : $square) {
        TablonFicha ficha = (TablonFicha) obj;
        #Borders are ignored
        if (ficha.getRow () == 1 || ficha.getColumn() == 1)
            continue;
        MutationEvent MutationEvent = new MutationEvent (ficha, MutationType.RETRACT);
        MutationEvent.setSquare ($grid.getSquare(ficha));
        MutationEvent.setOctogon ($grid.getOctogon(ficha));
        insert (MutationEvent);
    }
end

rule "A single water token cannot be supported by only one forest token"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.WATER_PARTICLE, $square : square)
    eval (isUnary ($ficha, $square, TokenType.FOREST))
    $grid : TablonGrid ()
then
    modify ($grid) { removeCell($ficha) }
    retract ($event);
    for (Object obj : $square) {
        TablonFicha ficha = (TablonFicha) obj;
        #Borders are ignored
        if (ficha.getRow () == 1 || ficha.getColumn() == 1)
            continue;
        MutationEvent MutationEvent = new MutationEvent (ficha, MutationType.RETRACT);
        MutationEvent.setSquare ($grid.getSquare(ficha));
        MutationEvent.setOctogon ($grid.getOctogon(ficha));
        insert (MutationEvent);
    }
end


rule "A forest token cannot be supported by only one forest token"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.FOREST, $square : square, $octogon : octogon)
    eval (isUnary ($ficha, $octogon, TokenType.FOREST))
    $grid : TablonGrid ()
then
    modify ($grid) { removeCell($ficha) }
    retract ($event);
    for (Object obj : $square) {
        TablonFicha ficha = (TablonFicha) obj;
        #Borders are ignored
        if (ficha.getRow () == 1 || ficha.getColumn() == 1)
            continue;        
        MutationEvent MutationEvent = new MutationEvent (ficha, MutationType.RETRACT);
        MutationEvent.setSquare ($grid.getSquare(ficha));
        MutationEvent.setOctogon ($grid.getOctogon(ficha));
        insert (MutationEvent);
    }
end

rule "Consume events after processing"
    ruleflow-group "evaluate"
    salience -10
when
    $event : MutationEvent ()
then
    retract ($event);
end

rule "At least ten water tokens are required for sustainability"
    ruleflow-group "confirm"
when
    $game : TablonGame (state == GameState.PLAY)
    $grid : TablonGrid ($tokens : waterTokens)
    eval ($tokens.size () < 10)
then
    modify ($game) { setGrid ($grid), setState (GameState.ENDED) }
    retract ($grid);  
    messageSender.sendEndGame ($game);    
end

rule "publish move complete"
    ruleflow-group "confirm"
when
    $game : TablonGame (state == GameState.PLAY)
    $move : TablonMove (status == MoveStatus.MOVED)
    $grid : TablonGrid()    
then
    modify ($game) { setGrid ($grid) }
    modify ($move) { setStatus (MoveStatus.EVALUATED) }
    messageSender.sendMoveComplete ($game, $move);
    retract ($move);    
end