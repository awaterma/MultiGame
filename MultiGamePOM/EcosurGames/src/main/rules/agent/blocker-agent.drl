/*
* Copyright (C) 2008 ECOSUR, Andrew Waterman and Max Pimm
* 
* Licensed under the Academic Free License v. 3.0. 
* http://www.opensource.org/licenses/afl-3.0.php
*/

/*
 * This rule package creates a strategic, "Blocker" player.
 *
 * A "blocker" player is a player that seeks always to block any possible
 * winning moves of his opponents.  The blocker strategy is first to see if
 * there are any scoring moves for the opposite team available, and if so,
 * to place a token in that location.  Scoring moves are ranked by there 
 * ability to win the game, and the highest scored location is used by the
 * blocker as its next move. 
 *
 * If no scoring moves are found, the blocker agent chooses the next available
 * cell adjacent to the opposition team, and if no such cell is found, the 
 * next available cell to his team.
 *
 * @author awaterma@ecosur.mx
*/

package mx.ecosur.multigame.impl.entity.gente;

import mx.ecosur.multigame.enums.GameState;
import mx.ecosur.multigame.impl.model.GridCell;

import mx.ecosur.multigame.impl.Color;

import java.util.HashSet;
import java.util.TreeSet;
import java.util.Random;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.UUID;

#Yellow must move first, and that move can only be at the center of the board
rule "first-move"
when
    game   : GenteGame (state == GameState.PLAY, $grid : grid)
    player : GenteStrategyAgent (turn == true, color == Color.YELLOW, nextMove==null)
    eval ($grid.getCells().isEmpty())
then
    GenteMove centerMove = new GenteMove (player, new GridCell (
        game.getRows() / 2, game.getColumns () / 2, player.getColor()));
    modify (player) { suggestNextMove (centerMove) }
end

rule "blocker-move"
    no-loop true
when
    game   : GenteGame (state == GameState.PLAY, $grid : grid)
    player : GenteStrategyAgent (turn == true, nextMove == null)
    eval (!$grid.getCells().isEmpty())
then
    HashSet<Color> colors = new HashSet<Color>();
    TreeSet<GenteMove> scoringMoves = player.determineScoringMoves(player.oppositionColors());
    GenteMove nextMove = null;
    
    if (scoringMoves.size() > 0) {
        for (GenteMove move : scoringMoves) {
            GridCell destination = (GridCell) move.getDestination();
            destination.setColor(player.getColor());
            nextMove = new GenteMove (player, destination);
            break;
        }
    }
    else {
        # Use the random algorithm
        TreeSet<GenteMove> possible = player.determineAvailableMoves();
        if (possible.size() == 0) 
            possible = player.determineAvailableMoves (player.oppositionColors());
        Random random = new Random ();
        for (GenteMove move : possible) {
            if (random.nextBoolean()) { 
                nextMove = move; 
                break;
            }
        }
        if (nextMove == null)
            for (GenteMove move : possible) {
                nextMove = move;
                break;
             }
    }
    modify (player) { suggestNextMove (nextMove) }
end