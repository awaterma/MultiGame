#created on: Feb 4, 2009
package mx.ecosur.multigame.manantiales

import mx.ecosur.multigame.GameState;
import mx.ecosur.multigame.MessageSender;

import mx.ecosur.multigame.Color;

import mx.ecosur.multigame.ejb.entity.Cell;
import mx.ecosur.multigame.ejb.entity.Game;
import mx.ecosur.multigame.ejb.entity.GamePlayer;
import mx.ecosur.multigame.ejb.entity.GameGrid;
import mx.ecosur.multigame.ejb.entity.Move;
import mx.ecosur.multigame.ejb.entity.Move.*;

import mx.ecosur.multigame.exception.CheckConstraint;

import mx.ecosur.multigame.ejb.entity.manantiales.Ficha;

import mx.ecosur.multigame.ejb.entity.manantiales.ManantialesMove;
import mx.ecosur.multigame.ejb.entity.manantiales.ManantialesPlayer;

import mx.ecosur.multigame.manantiales.Mode;
import mx.ecosur.multigame.manantiales.TokenType;

import java.util.HashSet;
import java.util.List;


function boolean isValid (GameGrid grid, ManantialesMove move) {
    Ficha destination = (Ficha) move.getDestination();
    Ficha current = (Ficha) grid.getLocation (destination);
    boolean ret = (current == null || !(current.getType() == TokenType.INTENSIVE_PASTURE));
    if (!ret)
        move.setStatus (Status.INVALID);
    return ret;
}

function int score (ManantialesPlayer player, ManantialesMove move) {
    switch (move.getType()) {
        case MANAGED_FOREST:
            player.setForested(player.getForested() +  1);
            break;
        case MODERATE_PASTURE:
            player.setModerate(player.getModerate() + 1);
            break;
        case INTENSIVE_PASTURE:
            player.setIntensive(player.getIntensive() + 1);
            break;
        case VIVERO:
            player.setVivero(player.getVivero() + 1);
            break;
        case SILVOPASTORAL:
            player.setSilvo(player.getSilvo() + 1);
            break;    
        default:
            break;
    }
    
    /* Set the points */
    int forested = player.getForested() * 1;
    int moderate = player.getModerate() * 2;
    int intensive = player.getIntensive() * 3;
    int silvo = player.getSilvo() * 4;
    
    return forested + moderate + intensive + silvo;
}

function boolean isWinner (Mode mode, GamePlayer gamePlayer) {
    ManantialesPlayer player = (ManantialesPlayer) gamePlayer;
    return player.getScore() >= mode.getWinningScore();
}

function boolean isBorder (Cell cell) {
    return (cell.getColumn () == 4 || cell.getRow () == 4);       
}

function GamePlayer incrementTurn (Move move) {
    GamePlayer player = move.getPlayer();    
    player.setTurn(false);

    /* Find next player */
    List<GamePlayer> players = player.getGame().getPlayers();
    int playerNumber = players.indexOf(player);
    GamePlayer nextPlayer = null;
    if (playerNumber == players.size() - 1) {
        nextPlayer = players.get(0);
    } else {
        nextPlayer = players.get(playerNumber + 1);
    }
    
    nextPlayer.setTurn (true);
    return nextPlayer;
}

# Sets the mode of the game, based upon its current state.
# TODO: Add in different available game modes (UI has not been
# implemented for PUZZLE modes nor RELOADED yet)le 
function Mode incrementMode (Mode mode) {
    switch (mode) {
        case CLASSIC:
            mode = Mode.SILVOPASTORAL;
            break;
        case SILVOPASTORAL:
            mode = Mode.RELOADED;
            break;             
    }
    
    return mode;
}

#Sets the players in the game so that Black has the first turn
rule "setup"
    agenda-group "initialize"
    no-loop true
when
    $game : Game (state == GameState.BEGIN);
then
    List<GamePlayer> players = $game.getPlayers();
    for (GamePlayer p : players) {
        if (p.getColor() == Color.YELLOW)
            p.setTurn(true);
        else
            p.setTurn(false);
    }
    GameGrid grid = new GameGrid ();
    #incrementMode($game.getMode());
    modify ($game) { setGrid (grid), setState (GameState.PLAY), setPlayers (players) } 
    MessageSender messageSender = new MessageSender();
    messageSender.sendPlayerChange($game);
    messageSender.sendStartGame($game);
end

rule "evaluate-move"
    agenda-group "verify"
when
    $game  : Game (state == GameState.PLAY, $grid : grid)
    $move  : ManantialesMove (status == Status.UNVERIFIED, player.turn == true)
    eval (isValid($game.getGrid(), $move))
then
    modify ($move) { setStatus (Status.VERIFIED) }    
end  

rule "silvopastoral must replace vivero" 
    agenda-group "verify"
when
    $game : Game (state == GameState.PLAY, $grid : grid)
    $move : ManantialesMove (status != Status.INVALID,
        type == TokenType.SILVOPASTORAL, replacementType != TokenType.VIVERO)
then
    modify ($move) { setStatus (Status.INVALID) }
end

rule "row contiguous intensive"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($row : row, $col : column, type == TokenType.INTENSIVE_PASTURE)
        $move : ManantialesMove (status != Status.INVALID, destination.row == $row, 
            type == TokenType.INTENSIVE_PASTURE)
        eval (!isBorder($tok1)) or eval (!isBorder($move.getDestination()))           
        eval (Math.abs ($col - $move.getDestination().getColumn()) <= 2) 
    then 
        modify ($move) { setStatus (Status.INVALID) }
end

rule "column contiguous intensive"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($row : row, $col : column, type == TokenType.INTENSIVE_PASTURE)
        $move : ManantialesMove (status != Status.INVALID, destination.column == $col, 
            type == TokenType.INTENSIVE_PASTURE)
        eval (!isBorder($tok1)) or eval (!isBorder($move.getDestination()))
        eval (Math.abs ($row - $move.getDestination().getRow()) <= 2) 
    then 
        modify ($move) { setStatus (Status.INVALID) }
end    

rule "border row contiguous intensive"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($row : row, $col : column, type == TokenType.INTENSIVE_PASTURE)
        $move : ManantialesMove (status != Status.INVALID, destination.row == $row, 
            type == TokenType.INTENSIVE_PASTURE)
        eval (isBorder($move.getDestination())) and eval (isBorder($tok1))            
        eval (Math.abs ($col - $move.getDestination().getColumn()) == 1) 
    then 
        modify ($move) { setStatus (Status.INVALID) }
end

rule "border column contiguous intensive"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($row : row, $col : column, type == TokenType.INTENSIVE_PASTURE)
        $move : ManantialesMove (status != Status.INVALID, destination.column == $col, 
            type == TokenType.INTENSIVE_PASTURE)
        eval (isBorder($move.getDestination())) and eval (isBorder($tok1))
        eval (Math.abs ($row - $move.getDestination().getRow()) == 1) 
    then 
        modify ($move) { setStatus (Status.INVALID) }
end 

# Enforces the constraint (by diagonal) that intensives cannot be contiguous
rule "diagonal contiguous intensive"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($col : column, $row : row, type == TokenType.INTENSIVE_PASTURE)
        $move : ManantialesMove (status != Status.INVALID, $destination : destination, 
            type == TokenType.INTENSIVE_PASTURE)
        eval (Math.abs($row - $destination.getRow()) == 1)
        eval (Math.abs($col - $destination.getColumn()) == 1) 
    then
        modify ($move) { setStatus (Status.INVALID) }
end 

#Enforces the arroyo constraint (only 2 developments that deforest on the border)
rule
    "northern border deforested"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($id : id, border == BorderType.NORTH, 
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $tok2 : Ficha (id > $id, $id2 : id, border == BorderType.NORTH, 
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))   
        $move : ManantialesMove (status != Status.INVALID, 
            destination.border == BorderType.NORTH, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))                            
    then
        CheckConstraint constraint = new CheckConstraint(
            "northern border deforested", $move.getPlayer(), $tok1, $tok2, $move);
        MessageSender messageSender = new MessageSender ();
        messageSender.sendCheckConstraint ($move, constraint);
end

#Enforces the arroyo constraint (only 2 developments that deforest on the border)
rule
    "eastern border deforested"
    agenda-group "verify"    
    no-loop true
    when
        $tok1 : Ficha ($id : id, border == BorderType.EAST, 
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $tok2 : Ficha (id > $id, $id2 : id, border == BorderType.EAST,
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))  
        $move : ManantialesMove (status != Status.INVALID, 
            destination.border == BorderType.EAST, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))       
    then
        CheckConstraint constraint = new CheckConstraint("eastern border deforested", $move.getPlayer(),
                $tok1, $tok2, $move);
        MessageSender messageSender = new MessageSender ();
        messageSender.sendCheckConstraint ($move, constraint);                
end

#Enforces the arroyo constraint (only 2 developments that deforest on the border)
rule
    "southern border deforested"
    agenda-group "verify"
    no-loop true    
    when
        $tok1 : Ficha ($id : id, border == BorderType.SOUTH, 
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $tok2 : Ficha (id > $id, $id2 : id, border == BorderType.SOUTH,
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $move : ManantialesMove (status != Status.INVALID, 
            destination.border == BorderType.SOUTH, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))     
    then
        insertLogical (
            new CheckConstraint("southern border deforested", $move.getPlayer(), 
                $tok1, $tok2, $move));
end

#Enforces the arroyo constraint (only 2 developments that deforest on the border)
rule
    "western border deforested"
    agenda-group "verify"
    no-loop true    
    when
        $tok1 : Ficha ($id : id, border == BorderType.WEST, 
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $tok2 : Ficha (id > $id, $id2 : id, border == BorderType.WEST,
            type in (TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $move : ManantialesMove (status != Status.INVALID, 
            destination.border == BorderType.WEST, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))                              
    then
        insertLogical (
            new CheckConstraint("western border deforested", $move.getPlayer(), 
                $tok1, $tok2, $move));
end

#Enforces Manantiales constraint (only 2 developments around the manantiales
#may deforest the land).
rule "manantiales"
    agenda-group "verify"
    no-loop true
    when
        $tok1 : Ficha ($id : id, manantial == true, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $tok2 : Ficha (id > $id, $id2 : id, manantial == true, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE)) 
        $move : ManantialesMove (status != Status.INVALID, 
            destination.manantial == true, type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))         
    then
        insertLogical (new CheckConstraint("Manantiales Dry", 
            $move.getPlayer(),$tok1, $tok2, $move));
end

# Executes a simple move
rule "execute-move"
    agenda-group "move"
when 
    $game  : Game (state == GameState.PLAY)
    $move  : ManantialesMove (player.turn == true, status == Status.VERIFIED)  
then
    #Modify gamegrid 
    GameGrid modifiedGrid = $game.getGrid();   
    modifiedGrid.updateCell ($move.getDestination());
    modify ($game) { setGrid (modifiedGrid) }
    modify ($move) { setStatus (Status.MOVED) }
    MessageSender messageSender = new MessageSender();
    messageSender.sendMoveComplete ($move);
end

#Enforces the constaint that no more than 32 sites can be deforested
rule "too many deforested sites"
    agenda-group "evaluate"
    no-loop true
    when
        $move : ManantialesMove (player.turn == true, destination.type in (
            TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
        $list : Number () from accumulate (
            Ficha ($id : id, type in (
                TokenType.MODERATE_PASTURE, TokenType.INTENSIVE_PASTURE))
            count ($id)) 
        eval ($list.intValue() > 31)
    then
        insertLogical (new CheckConstraint("Too many deforested sites", 
            $move.getPlayer(), $list));
end

rule "remove-replaced-token-from-player"
    agenda-group "evaluate"
    no-loop true
when
    $move : ManantialesMove (current != null, player.turn == true, 
        status == Status.MOVED)
then
    ManantialesPlayer player = (ManantialesPlayer) $move.getPlayer();
    switch ($move.getType()) {
        case MANAGED_FOREST:
            player.setForested(player.getForested() -  1);
            break;
        case MODERATE_PASTURE:
            player.setModerate(player.getModerate() - 1);
            break;
        case INTENSIVE_PASTURE:
            player.setIntensive(player.getIntensive() - 1);
            break;
        case VIVERO:
            player.setVivero(player.getVivero() - 1);
            break;
        case SILVOPASTORAL:
            player.setSilvo(player.getSilvo() - 1);
            break;    
        default:
            break;
    }
    modify ($move) { setPlayer (player) };
end

rule "score"
    agenda-group "evaluate"
    no-loop true
when
    $game  : Game (state == GameState.PLAY)
    $move  : ManantialesMove (player.turn == true, status == Status.MOVED)
then
    ManantialesPlayer player = (ManantialesPlayer) $move.getPlayer();
    player.setScore(score (player, $move));
    modify ($move) { setPlayer (player), setStatus (Status.EVALUATED) };
end   

# TODO: re-write so this sends a list of all violated check-constraints across
# the wire.
rule "check-constraints"
    agenda-group "evaluate"
    no-loop true
    when
        $move : ManantialesMove ()
        $occurrences : HashSet () 
            from accumulate ($checkConstraint : CheckConstraint (),
                    init ( HashSet set = new HashSet();),
                    action (set.add ($checkConstraint);),
                    reverse (set.remove ($checkConstraint);),
                    result (set))
    then
        MessageSender messageSender = new MessageSender ();
        for (Object obj : $occurrences) {
            CheckConstraint constraint = (CheckConstraint) obj;
            messageSender.sendCheckConstraint ($move, constraint);
        }
end

# Determines if there is a winner 
# TODO:  need to query game, or move for winning score number (based on type
# of game.
#rule "determine-winner"
#    agenda-group "evaluate"
#    no-loop true
#when
#    $game  : ManantialesGame (state == GameState.PLAY)
#    $move  : ManantialesMove ($player : player, player.turn == true, 
#        status == Status.EVALUATED)
#    #eval (isWinner ($game.getMode(), $player))
#then
#    modify ($game) { setState (GameState.END) };
#    MessageSender messageSender = new MessageSender();
#    messageSender.sendEndGame ($game);
#end

rule "increment-turn"
    agenda-group "evaluate"
    no-loop true
    salience -1
when
    game  : Game (state == GameState.PLAY)
    move  : Move (player.turn == true, status == Status.EVALUATED)
then
    GamePlayer player = incrementTurn (move);
    MessageSender messageSender = new MessageSender();
    messageSender.sendPlayerChange(player.getGame());
end