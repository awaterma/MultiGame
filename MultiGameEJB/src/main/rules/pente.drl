package mx.ecosur.multigame.pente;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.commons.collections.buffer.PriorityBuffer;

import mx.ecosur.multigame.GameGrid;
import mx.ecosur.multigame.Cell;
import mx.ecosur.multigame.Color;
import mx.ecosur.multigame.GameGrid;
import mx.ecosur.multigame.GameState;

import mx.ecosur.multigame.ejb.entity.Move.Status;

import mx.ecosur.multigame.ejb.entity.Player;
import mx.ecosur.multigame.ejb.entity.pente.PenteGame;
import mx.ecosur.multigame.ejb.entity.pente.PentePlayer;
import mx.ecosur.multigame.ejb.entity.pente.PenteMove;


#functions for the Game of PENTE

/*
    Determines if the destination of the requested move
    is in the center of the grid.
*/
function boolean isCenter (PenteGame game, PenteMove move) {
    Dimension size = game.getSize();
    Cell destination = move.getDestination ();
    
    int centerWidth = (int) size.getWidth()/2;
    int centerHeight = (int) size.getHeight()/2;
  
    return (destination.getRow () == centerHeight && destination.getColumn() == centerWidth);
}

/*
    Determines if the destination of the requested move is
    empty on the grid.
*/
function boolean isEmpty (GameGrid grid, PenteMove move) {
    Cell destination = move.getDestination();
    Cell current = grid.getLocation (destination.getRow(), destination.getColumn());
    return (current == null);
}

/*
    Determines if the move captures any two pieces of an opponent's color
    in any direction.
*/
function boolean isCapture (PenteGame game, PenteMove move) {
    List<Player> players = game.getPlayers();
    ArrayList<Color> colors = new ArrayList<Color>();
    for (Player p : players) {
        if (p.equals (move.getPlayer()))
            continue;
        colors.add(p.getColor());
    }
    
    Set<Cell> captures = move.getCaptures((Color []) colors.toArray());
    return (captures.size() > 0);
}


/*
    Removes the set of tokens that have been captured by a 
    specific move.
*/

function GameGrid removeCaptures (PenteGame game, PenteMove move) {
    List<Player> players = game.getPlayers();
    ArrayList<Color> colors = new ArrayList<Color>();
    for (Player p : players) {
        if (p.equals (move.getPlayer()))
            continue;
        colors.add(p.getColor());
    }

    GameGrid grid = game.getGrid();
    Set<Cell> captures = move.getCaptures((Color []) colors.toArray());
    for (Cell capture : captures) {
        grid.removeCell (capture);
    }
    return grid;
}


/*
    Determines if the game has a winner.
*/
function boolean hasWinner (PenteGame game) {
    return game.getWinners().size() > 0;
}

/*
    Gets the winner from a specified game.  For more complicated payoff
    schemas, this function should return a PriorityQueue of Players 
    based upon positions on the board.
*/
function Player getWinner (PenteGame game) {
    PriorityBuffer queue = game.getWinners();
    return (Player) queue.remove ();
}


#Rules for the game of PENTE

#Sets up the first turn

rule "setup-turns"
    agenda-group "initialize"
when
    game : PenteGame (state == GameState.SETUP)
then
    List<Player> players = game.getPlayers();
    for (Player p : players) {
        if (p.getColor() == Color.BLACK) {
            p.setTurn(true);
            break;
        }
    }
    modify (game) { setPlayers (players) }
    modify (game) { setState (GameState.BEGIN) }
end


#Sets up the empty game grid and sets thate game into the PLAY state
rule "setup-board"
    agenda-group "initialize"
when
    game : PenteGame (state == GameState.BEGIN)
then
    GameGrid grid = new GameGrid ();
    modify (game) { setGrid (grid) }
    modify (game) { setState (GameState.PLAY) }
end

#Black must move first, and that move can only be at the center of the board
rule "first-move"
    agenda-group "evaluate"
when
    game  : PenteGame (state == GameState.PLAY, $grid : grid)
    grid  : GameGrid (cells.size == 0)
    move  : PenteMove (player.turn == true, player.color == Color.BLACK)
    eval (isCenter (game, move))    
then
    modify (move) { setStatus (Status.VERIFIED) }
end

#Subsequent moves must occur on a non-empty board, on empty locations
rule "evaluate-move"
    agenda-group "evaluate"
when
    game  : PenteGame (state == GameState.PLAY, $grid : grid)
    grid  : GameGrid (cells.size > 0)
    move  : PenteMove (player.turn == true)
    eval (isEmpty (game.getGrid(), move))   
then
    modify (move) { setStatus (Status.VERIFIED) }
end   

# Executes a simple move
rule "execute-move"
    agenda-group "move"
when 
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Move.Status.VERIFIED)  
then 
    GameGrid modifiedGrid = game.getGrid();   
    modifiedGrid.updateCell (move.getDestination());
    modify (game) { setGrid (modifiedGrid) }
end

# Captures any opposition tokens
rule "execute-capture"
    agenda-group "analyze"
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Move.Status.VERIFIED)
    eval (isCapture (game, (PenteMove) move))
then  
    GameGrid grid = removeCaptures (game, (PenteMove) move);
end  

# Finds the winner (currently, there is no payoff schema in place, a game win
# is simply a "win.")
rule "find-the-winner"
    agenda-group "analyze"
when
    game  : PenteGame (state == GameState.PLAY)
    move  : PenteMove (player.turn == true, status == Move.Status.VERIFIED)
    eval (hasWinner(game))
then
    Player winner = getWinner (game);
    winner.setWins (winner.getWins () + 1);
    modify (game) { setState (GameState.END) }
end