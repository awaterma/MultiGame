package mx.ecosur.multigame.pasale;

/*
* Copyright (C) 2009 ECOSUR, Andrew Waterman
*
* Licensed under the Academic Free License v. 3.0.
* http://www.opensource.org/licenses/afl-3.0.php
*/

import java.util.ArrayList;
import java.util.Date;
import java.util.SortedSet;
import java.util.List;

import mx.ecosur.multigame.impl.Color;
import mx.ecosur.multigame.enums.GameState;
import mx.ecosur.multigame.enums.MoveStatus;

import mx.ecosur.multigame.MessageSender;

import mx.ecosur.multigame.impl.entity.pasale.PasaleFicha;
import mx.ecosur.multigame.impl.entity.pasale.PasaleGame;
import mx.ecosur.multigame.impl.entity.pasale.PasaleGrid;
import mx.ecosur.multigame.impl.entity.pasale.PasaleMove;
import mx.ecosur.multigame.impl.entity.pasale.PasalePlayer;
import mx.ecosur.multigame.impl.enums.pasale.TokenType;

import mx.ecosur.multigame.impl.util.pasale.MutationEvent;

import function mx.ecosur.multigame.impl.util.pasale.RuleFunctions.*;

/**
    Pasale Compadre is a meta-game built with the purpose of players adding in their own rules to control
    resource usage.  The game has a set of environmental constraints, which, under the right
    circumstances will create a catastrophic failure.

    Game design:  Luis Garc’a Barrios
    Game implementation:  Andrew Glenn Waterman
*/

#globals
global MessageSender messageSender;
global Integer dimension;

#dialect
dialect "java"

#rules

rule "verify-move"
    ruleflow-group "verify"
when
    $game  : PasaleGame (state == GameState.PLAY, $grid : grid)
    $move  : PasaleMove (badYear == false, status == MoveStatus.UNVERIFIED, player.turn == true)
    eval (hasPathToWater((PasaleFicha) $move.getDestinationCell(), (PasaleGrid) $grid))
    eval ( ((PasaleFicha) $grid.getLocation ($move.getDestinationCell())).getType ().equals (TokenType.FOREST))
then
    modify ($move) { setStatus (MoveStatus.VERIFIED) }
end


rule "verify-update-move"
    ruleflow-group "verify"
when
    $game  : PasaleGame (state == GameState.PLAY, $grid : grid)
    $move  : PasaleMove (badYear == false, status == MoveStatus.UNVERIFIED, player.turn == true)
    eval ( ( (PasaleFicha) $move.getDestinationCell() ).getType().equals (TokenType.SILVOPASTORAL) )
    eval ( ( (PasaleFicha) $grid.getLocation ($move.getDestinationCell()) ).getType().equals (TokenType.POTRERO))
then
    modify ($move) { setStatus (MoveStatus.VERIFIED) }
end

rule "do-move"
   ruleflow-group "move"
when
    $game  : PasaleGame  (state == GameState.PLAY, $grid : grid)
    $move  : PasaleMove  (badYear == false, status == MoveStatus.VERIFIED, player.turn == true)
then
    PasaleFicha ficha = (PasaleFicha) $move.getDestinationCell();
    $grid.updateCell (ficha);
    PasaleGrid tgrid = (PasaleGrid) $grid;
    MutationEvent mutation = new MutationEvent (ficha);
    mutation.setSquare (tgrid.getSquare(ficha));
    mutation.setOctogon (tgrid.getOctogon(ficha));
    mutation.setCross (tgrid.getCross(ficha));
    incrementTurn ($game, $move);
    modify ($move) { setStatus (MoveStatus.MOVED) }
    insert (tgrid);
    insert (mutation);
    for (PasaleFicha particle : mutation.getSquare()) {
        if (particle.getRow() == 1 || particle.getRow() == ($game.getRows() ) || particle.getColumn() == 1
            || particle.getColumn() == ($game.getColumns()))
            continue;
        MutationEvent event = new MutationEvent (particle);
        event.setSquare(tgrid.getSquare(particle));
        insert (event);
    }
    /* Cross does not need to be walked seperately and inserted as it is covered in octogon */
    for (PasaleFicha forest : mutation.getOctogon()) {
        if (forest.getRow () == 1 || forest.getRow() == ($game.getRows() -1 )|| forest.getColumn() == 1
            || forest.getColumn() == ($game.getColumns() - 1))
            continue;
        MutationEvent event = new MutationEvent (forest);
        event.setSquare(tgrid.getSquare(forest));
        event.setOctogon(tgrid.getOctogon(forest));
        event.setCross (tgrid.getCross(forest));
        insert (event);
    }

end

# Environmental constraints

rule "Edges must not be effected"
    ruleflow-group "evaluate"
    salience 10
when
    $game  : PasaleGame (state == GameState.PLAY)
    $event : MutationEvent (ficha.column == 1 || ficha.row == 1 ||
        ficha.column == ($game.columns - 1) ||ficha.row == ($game.rows - 1))
then
    retract ($event);
end

rule "A Potrero token must be supported by 2 soil tokens in the SQUARE"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.POTRERO, $square : square, $octo : octogon)
    eval (isUnsupported (2, $ficha, $square, TokenType.SOIL_PARTICLE))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    /* Cross based implications are included in the octogon */
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A Silvopastoral token must be supported by 1 soil tokens in the SQUARE"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.SILVOPASTORAL, $square : square, $octo : octogon)
    eval (isUnsupported (1, $ficha, $square, TokenType.SOIL_PARTICLE))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    /* Cross based implications are included in the octogon */
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A Potrero token must be supported by 1 forest token in the CROSS (Silvopastoral counts as 1/2 a Forest token)"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.POTRERO, $square : square, $octo : octogon,
        $cross : cross)
    eval (isUnsupported (1, $ficha, $cross, TokenType.FOREST) && isUnsupported (2, $ficha, $cross, TokenType.SILVOPASTORAL))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A Silvopastoral token must be supported by 1 forest token in the CROSS (Silvopastoral counts as 1/2 a Forest token)"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.SILVOPASTORAL, $square : square, $octo : octogon,
        $cross : cross)
    eval (isUnsupported (1, $ficha, $cross, TokenType.FOREST) && isUnsupported(2, $ficha, $square, TokenType.SILVOPASTORAL))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A soil token must be supported by 1 forest tokens in the SQUARE (Silvopastoral counts as 1/2 a Forest token)"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.SOIL_PARTICLE, $square : square, $octo : octogon)
    eval (isUnsupported (1, $ficha, $square, TokenType.FOREST) && isUnsupported(2, $ficha, $square, TokenType.SILVOPASTORAL))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A water token must be supported by 2 forest tokens in the SQUARE (Silvopastoral counts as 1/2 a Forest token)"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.WATER_PARTICLE, $square : square, $octo : octogon)
    eval (isUnsupported (2, $ficha, $square, TokenType.FOREST) && isUnsupported(4, $ficha,$square,TokenType.SILVOPASTORAL))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end


rule "A forest token must be suported by 2 forest tokens in the OCTOGON (Silvopastoral counts as 1/2 a Forest token)"
    ruleflow-group "evaluate"
when
    $event : MutationEvent ($ficha : ficha, ficha.type == TokenType.FOREST, $square : square, $octo : octogon)
    eval (isUnsupported (2, $ficha, $octo, TokenType.FOREST) && isUnsupported(4, $ficha, $octo, TokenType.SILVOPASTORAL))
    $grid : PasaleGrid ()
    $game : PasaleGame (state == GameState.PLAY)
    eval ($grid.getLocation($ficha) != null)
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "A potrero token must have a path to water in the CROSS"
    ruleflow-group "evaluate"
when
        $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.POTRERO,  $square : square, $octo : octogon)
        $game : PasaleGame (state == GameState.PLAY)
        $grid  : PasaleGrid()
        eval (!hasPathToWater ($ficha, $grid));
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end


rule "A silvopastoral token must have a path to water in the CROSS"
    ruleflow-group "evaluate"
when
        $event : MutationEvent ($ficha :  ficha, ficha.type == TokenType.SILVOPASTORAL,  $square : square, $octo : octogon)
        $game : PasaleGame (state == GameState.PLAY)
        $grid  : PasaleGrid()
        eval (!hasPathToWater ($ficha, $grid));
then
    modify ($grid) { removeCell($ficha) }
    messageSender.sendConditionTriggered($game, $event);
    retract ($event);
    ArrayList<MutationEvent> implications = findImplications ($grid, $square);
    implications.addAll(findImplications($grid, $octo));
    for (MutationEvent event : implications) {
        insert (event);
    }
end

rule "Consume events after processing"
    ruleflow-group "confirm"
when
    $event : MutationEvent ()
then
    retract ($event);
end

rule "publish move complete"
    ruleflow-group "confirm"
when
    $game : PasaleGame (state == GameState.PLAY)
    $move : PasaleMove (status == MoveStatus.MOVED)
    $grid : PasaleGrid()    
then
    modify ($game) { setGrid ($grid) }
    modify ($move) { setStatus (MoveStatus.EVALUATED) }
    messageSender.sendMoveComplete ($game, $move);
    retract ($move);    
end